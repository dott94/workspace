My project is currently broken up into two programs. The Server and the client. After you make, you can launch the server executable with ./server portnum and client with ./client localhost portnum. There are warnings during the compilation, but everything builds just fine. After the server is running, we are now able to connect the client. Using the ssl client or the ./client, we can connect and the handshake process begins. The client connects nicely with the server and you can now send a message from the ssl client to the server. Unfortunately, I was only able to construct a separate client and server. They are able to connect via ssl but I was unable to bring the whole systems together and sniff communication. I can also run the ssl server and connect my client. I built all of the individual pieces of the system and spent countless hours on this, but my inexperience with ssl and system calls really showed. To complete the assignment, I would need to have the ssl server relay the message to the ssl client then on to the server. All pieces of this project are built and run properly, but the actual “proxy” is not technically assembled together. I hope that my hard work shows and some credit is given for this project. OpenSSL is a lot to learn in one week! My approach to building this was first to build a client and a server and connect via socket. My next step was to implement the ssl logic for the client and server respectively. 
The client and server can now execute the proper handshaking process and connect properly. 


QUESTION:
What would an attacker require to launch a MITM attack, if the client did correctly verify the certificate presented by the server and certificate authorities are used for the client to verify server certificates?

ANSWER:
At this point we are assuming that the client made a request to a server, a certificate was presented and MITMProxy provided the proper information to the CA and the SSL handshake process has started. Although this seems like the attacker is making progress, there are still several complications in launching this attack. 

Sometimes the common name of the certificate is different from the hostname that the client is intending to connect to. Within the SSL field there is an option known as "Subject alternative name". This allows the certificate to provide multiple alternate domain names. Luckily for the hacker, if any of the specified domain names match the expected domain name, the client will continue. The attacker needs to make sure that he extracts both the common name of the certification as well as all of the subject alternate names, then add them all to the "fake" certificate.

Another issue an attacker may face is server name indication. This process allows a server to offer multiple domains with independent certificates to share the same IP. SNI raises issues with hackers because it breaks the certificate sniffing process. If a hacker connects without using SNI, we get a default certificate that could potentially have nothing to do with the client. In order to work around this, the hacker needs to allow the SSL handshake to continue right after the client connects, just until the SNI value was passed to them. You then need to pause communication and initiate your own upstream connection using the SNI you just got. You will then be served the correct upstream certificate and you can now deduce the correct domain names(common name + subject alternate names). 

The attacker is now connected to the host, so watch out!
